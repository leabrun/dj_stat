{"ast":null,"code":"var V = Object.defineProperty;\nvar Y = (r, t, e) => t in r ? V(r, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: e\n}) : r[t] = e;\nvar y = (r, t, e) => Y(r, typeof t != \"symbol\" ? t + \"\" : t, e);\nvar $ = Object.defineProperty,\n  k = (r, t, e) => t in r ? $(r, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : r[t] = e,\n  q = (r, t, e) => k(r, t + \"\", e);\nfunction z(r, t) {\n  return e => e instanceof r && e.type === t;\n}\nfunction P(r, t) {\n  t || (t = []);\n  const e = Symbol(r);\n  class c extends Error {\n    constructor(...s) {\n      const a = typeof t == \"function\" ? t(...s) : typeof t == \"string\" ? [t] : t || [];\n      super(...a), q(this, \"type\", e), this.name = r;\n    }\n  }\n  return Object.defineProperty(c, \"name\", {\n    value: r\n  }), [c, z(c, e)];\n}\nconst [G, M] = P(\"CancelledError\", \"Promise was canceled\"),\n  [H, N] = P(\"TimeoutError\", (r, t) => [`Timeout reached: ${r}ms`, {\n    cause: t\n  }]),\n  B = Symbol(\"Resolved\");\nfunction C(r) {\n  return Array.isArray(r) && r[0] === B;\n}\nfunction J(r) {\n  return [B, r];\n}\nfunction x(r, t) {\n  return r.reject = t.reject, r.abort = t.abort, r;\n}\nclass m extends Promise {\n  constructor(e, c) {\n    let o, s;\n    super((a, i) => {\n      let v, u;\n      typeof e == \"function\" ? (v = e, u = c) : u = e;\n      const d = [],\n        j = n => (...h) => {\n          const p = n(...h);\n          return d.forEach(F => F()), p;\n        },\n        g = new AbortController(),\n        {\n          signal: l\n        } = g;\n      s = n => {\n        !l.aborted && g.abort(n);\n      };\n      const b = () => l.reason,\n        w = n => {\n          const h = () => {\n            n(b());\n          };\n          l.addEventListener(\"abort\", h, !0);\n          const p = () => {\n            l.removeEventListener(\"abort\", h, !0);\n          };\n          return d.push(p), p;\n        },\n        D = j(n => {\n          a(n), s(J(n));\n        });\n      o = j(n => {\n        i(n), s(n);\n      }), u || (u = {});\n      const {\n        abortSignal: f,\n        rejectOnAbort: A = !0\n      } = u;\n      if (f) if (f.aborted) {\n        const {\n          reason: n\n        } = f;\n        if (A) return o(n);\n        s(n);\n      } else {\n        const n = () => {\n          s(f.reason);\n        };\n        f.addEventListener(\"abort\", n), d.push(() => {\n          f.removeEventListener(\"abort\", n);\n        });\n      }\n      A && w(i);\n      const {\n        timeout: E\n      } = u;\n      if (E) {\n        const n = setTimeout(() => {\n          s(new H(E));\n        }, E);\n        d.push(() => {\n          clearTimeout(n);\n        });\n      }\n      const L = () => l.aborted,\n        S = () => C(b()),\n        T = () => {\n          const n = b();\n          return C(n) ? n[1] : void 0;\n        };\n      try {\n        const n = v && v(D, o, {\n          abortReason: b,\n          abortSignal: l,\n          isAborted: L,\n          isResolved: S,\n          onAborted: w,\n          onResolved: h => w(() => {\n            S() && h(T());\n          }),\n          resolved: T,\n          throwIfAborted() {\n            if (L()) throw b();\n          }\n        });\n        n instanceof Promise && n.catch(o);\n      } catch (n) {\n        o(n);\n      }\n    });\n    /**\n     * Aborts the promise execution using the specified reason.\n     *\n     * Not that this method doesn't reject the promise but notifies the executor using its context.\n     * To perform the same operation but also reject the promise, use the `reject()` method.\n     * @param reason - abort reason.\n     * @see reject\n     */\n    y(this, \"abort\");\n    /**\n     * Rejects the initially created promise.\n     *\n     * This method not only aborts the signal passed to the executor, but also rejects the\n     * promise itself calling all chained listeners.\n     *\n     * The reason passed to the method is being passed as-is to the executor's context.\n     */\n    y(this, \"reject\");\n    this.abort = s, this.reject = o;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new m(async (o, s, a) => {\n      try {\n        o(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new m((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new G());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return x(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return x(super.then(e, c), this);\n  }\n}\nfunction I(r, t) {\n  return r.resolve = t.resolve, r;\n}\nclass R extends m {\n  constructor(e, c) {\n    let o, s;\n    typeof e == \"function\" ? (o = e, s = c) : s = e;\n    let a;\n    super((i, v, u) => {\n      a = i, o && o(i, v, u);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    y(this, \"resolve\");\n    this.resolve = a;\n  }\n  /**\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new R((o, s, a) => {\n      try {\n        Promise.resolve(e(a)).then(o, s);\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new R((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return I(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return I(super.then(e, c), this);\n  }\n}\nexport { m as AbortablePromise, G as CancelledError, R as ManualPromise, H as TimeoutError, M as isCancelledError, C as isPromiseResolveResult, N as isTimeoutError };","map":{"version":3,"names":["$","Object","defineProperty","k","u","r","t","e","enumerable","configurable","writable","value","q","c","z","type","P","Symbol","Error","constructor","s","a","name","G","M","H","N","cause","B","C","Array","isArray","J","x","reject","abort","m","Promise","o","i","v","d","j","n","h","p","forEach","F","g","AbortController","signal","l","aborted","b","abortReason","reason","w","wrapped","addEventListener","cleanup","removeEventListener","push","D","abortSignal","f","rejectOnAbort","A","listener","timeout","E","setTimeout","clearTimeout","L","isAborted","S","isResolved","T","resolved","onAborted","onResolved","throwIfAborted","catch","y","fn","resolve","cancel","then","finally","I","R"],"sources":["/home/leabrun/python_/KWORK/dj/front/node_modules/better-promises/node_modules/.pnpm/error-kid@0.0.7/node_modules/error-kid/dist/index.js","/home/leabrun/python_/KWORK/dj/front/node_modules/better-promises/src/errors/CancelledError.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/better-promises/src/errors/TimeoutError.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/better-promises/src/promises/resolve.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/better-promises/src/promises/AbortablePromise.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/better-promises/src/promises/ManualPromise.ts"],"sourcesContent":["var f = Object.defineProperty;\nvar u = (r, t, e) => t in r ? f(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar c = (r, t, e) => u(r, typeof t != \"symbol\" ? t + \"\" : t, e);\nfunction a(r, t) {\n  return (e) => e instanceof r && e.type === t;\n}\nfunction p(r, t) {\n  t || (t = []);\n  const e = Symbol(r);\n  class n extends Error {\n    constructor(...i) {\n      const o = typeof t == \"function\" ? t(...i) : typeof t == \"string\" ? [t] : t || [];\n      super(...o);\n      c(this, \"type\", e);\n      this.name = r;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: r }), [n, a(n, e)];\n}\nfunction l(r, t, e) {\n  const n = Symbol(r);\n  class s extends p(r, e)[0] {\n    constructor(...o) {\n      super(...o);\n      c(this, \"data\");\n      c(this, \"type\", n);\n      this.data = t(...o);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: r }), [s, a(s, n)];\n}\nexport {\n  p as errorClass,\n  l as errorClassWithData,\n  a as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n","import { errorClass } from 'error-kid';\r\n\r\nexport const [CancelledError, isCancelledError] =\r\n  errorClass('CancelledError', 'Promise was canceled');","import { errorClass } from 'error-kid';\r\n\r\nexport const [TimeoutError, isTimeoutError] =\r\n  errorClass<[timeout: number, cause?: unknown]>(\r\n    'TimeoutError',\r\n    (timeout, cause) => [`Timeout reached: ${timeout}ms`, { cause }],\r\n  );\r\n","export type PromiseResolveResult<T> = [typeof RESOLVED_SYMBOL, T];\r\n\r\nconst RESOLVED_SYMBOL = Symbol('Resolved');\r\n\r\n/**\r\n * @return True if passed value determines that the promise was resolved.\r\n * @param value\r\n * @example\r\n * const promise = new ManualPromise(async (res, rej, signal) => {\r\n *   // Imitate something async here.\r\n *   await new Promise(res => setTimeout(res, 1000));\r\n *\r\n *   if (isResolved(signal.reason)) {\r\n *     // It means that ManualPromise was resolved outside. We probably want to stop executing\r\n *     // the function as long as the result will not affect anything.\r\n *     return;\r\n *   }\r\n *\r\n *   // Otherwise keep doing what we do.\r\n * });\r\n */\r\nexport function isPromiseResolveResult(value: unknown): value is PromiseResolveResult<unknown> {\r\n  return Array.isArray(value) && value[0] === RESOLVED_SYMBOL;\r\n}\r\n\r\nexport function withResolved<T>(value: T): PromiseResolveResult<T> {\r\n  return [RESOLVED_SYMBOL, value];\r\n}","import type {\r\n  PromiseExecutorFn,\r\n  PromiseOnRejectedFn,\r\n  PromiseRejectFn,\r\n  PromiseOnFulfilledFn,\r\n  PromiseResolveFn,\r\n  PromiseOptions,\r\n  Maybe,\r\n  WithFnFunction,\r\n} from './types.js';\r\nimport { TimeoutError } from '../errors/TimeoutError.js';\r\nimport { CancelledError } from '../errors/CancelledError.js';\r\nimport { isPromiseResolveResult, withResolved } from './resolve.js';\r\n\r\nfunction reassignProps<P extends AbortablePromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: AbortablePromise<any>,\r\n): P {\r\n  childPromise.reject = parentPromise.reject;\r\n  childPromise.abort = parentPromise.abort;\r\n  return childPromise;\r\n}\r\n\r\n/**\r\n * Improved version of the JavaScript Promise.\r\n */\r\nexport class AbortablePromise<Result> extends Promise<Result> {\r\n  /**\r\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\r\n   * was returned.\r\n   * @param fn - function returning promise result.\r\n   * @param options - additional options.\r\n   */\r\n  static fn<T>(fn: WithFnFunction<T>, options?: PromiseOptions): AbortablePromise<T> {\r\n    return new AbortablePromise(async (res, rej, context) => {\r\n      try {\r\n        res(await fn(context));\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): AbortablePromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): AbortablePromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): AbortablePromise<Awaited<T>> {\r\n    return this.fn(() => value) as AbortablePromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject<T = never>(reason?: any): AbortablePromise<T> {\r\n    return new AbortablePromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new AbortablePromise instance using only options.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(options?: PromiseOptions);\r\n  /**\r\n   * Creates a new AbortablePromise instance using specified executor and additional options.\r\n   * @param executor - promise executor.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(executor?: PromiseExecutorFn<Result>, options?: PromiseOptions);\r\n  constructor(\r\n    executorOrOptions?: PromiseExecutorFn<Result> | PromiseOptions,\r\n    maybeOptions?: PromiseOptions,\r\n  ) {\r\n    let reject!: PromiseRejectFn;\r\n    let abort!: (reason: unknown) => void;\r\n    super((res, rej) => {\r\n      let executor: PromiseExecutorFn<Result> | undefined;\r\n      let options: PromiseOptions | undefined;\r\n\r\n      if (typeof executorOrOptions === 'function') {\r\n        executor = executorOrOptions;\r\n        options = maybeOptions;\r\n      } else {\r\n        options = executorOrOptions;\r\n      }\r\n\r\n      //#region Cleanup section.\r\n      const cleanupFns: VoidFunction[] = [];\r\n      const withCleanup = <F extends (...args: any) => any>(\r\n        fn: F,\r\n      ): (...args: Parameters<F>) => ReturnType<F> => {\r\n        return (...args) => {\r\n          const result = fn(...args);\r\n          cleanupFns.forEach(fn => fn());\r\n          return result;\r\n        };\r\n      };\r\n      //#endregion\r\n\r\n      // We are going to use our controller signal in the executor because we can control it.\r\n      // We can't say the same about the abort signal passed from above, we can't abort it by\r\n      // ourselves.\r\n      const controller = new AbortController();\r\n      const { signal } = controller;\r\n      abort = reason => {\r\n        !signal.aborted && controller.abort(reason);\r\n      };\r\n      const abortReason = () => signal.reason;\r\n      const onAborted = (listener: (reason: unknown) => void): VoidFunction => {\r\n        const wrapped = () => {\r\n          listener(abortReason());\r\n        };\r\n        signal.addEventListener('abort', wrapped, true);\r\n\r\n        const cleanup = () => {\r\n          signal.removeEventListener('abort', wrapped, true);\r\n        };\r\n        cleanupFns.push(cleanup);\r\n        return cleanup;\r\n      };\r\n\r\n      // Enhance resolve and reject functions with cleanup and controller abortion.\r\n      const resolve = withCleanup((result: Result) => {\r\n        res(result);\r\n        abort(withResolved(result));\r\n      }) as PromiseResolveFn<Result>;\r\n      reject = withCleanup(reason => {\r\n        rej(reason);\r\n        abort(reason);\r\n      });\r\n\r\n      //#region Process abortSignal option.\r\n      options ||= {};\r\n      const { abortSignal, rejectOnAbort = true } = options;\r\n      if (abortSignal) {\r\n        if (abortSignal.aborted) {\r\n          const { reason } = abortSignal;\r\n          if (rejectOnAbort) {\r\n            return reject(reason);\r\n          }\r\n          abort(reason);\r\n        } else {\r\n          // When the passed abort signal aborts, we are also aborting our locally created signal.\r\n          const listener = () => {\r\n            abort(abortSignal.reason);\r\n          };\r\n          abortSignal.addEventListener('abort', listener);\r\n          cleanupFns.push(() => {\r\n            abortSignal.removeEventListener('abort', listener);\r\n          });\r\n        }\r\n      }\r\n      //#endregion\r\n\r\n      //#region Process rejectOnAbort option.\r\n      rejectOnAbort && onAborted(rej);\r\n      //#endregion\r\n\r\n      //#region Process timeout option.\r\n      const { timeout } = options;\r\n      if (timeout) {\r\n        const timeoutId = setTimeout(() => {\r\n          abort(new TimeoutError(timeout));\r\n        }, timeout);\r\n\r\n        cleanupFns.push(() => {\r\n          clearTimeout(timeoutId);\r\n        });\r\n      }\r\n      //#endregion\r\n\r\n      const isAborted = () => signal.aborted;\r\n      const isResolved = () => isPromiseResolveResult(abortReason());\r\n      const resolved = () => {\r\n        const reason = abortReason();\r\n        return isPromiseResolveResult(reason) ? reason[1] as Result : undefined;\r\n      };\r\n      try {\r\n        const result = executor && executor(resolve, reject, {\r\n          abortReason,\r\n          abortSignal: signal,\r\n          isAborted,\r\n          isResolved,\r\n          onAborted,\r\n          onResolved: listener => onAborted(() => {\r\n            isResolved() && listener(resolved() as Result);\r\n          }),\r\n          resolved,\r\n          throwIfAborted() {\r\n            if (isAborted()) {\r\n              throw abortReason();\r\n            }\r\n          },\r\n        });\r\n\r\n        // If a promise was returned, we want to handle its rejection because the JS Promise\r\n        // will not do it for us. Not catching the promise rejection this way, an unhandled promise\r\n        // rejection error will be thrown. We also need to perform reject properly cleaning up\r\n        // all effects.\r\n        if (result instanceof Promise) {\r\n          result.catch(reject);\r\n        }\r\n      } catch (e) {\r\n        // The wrapped executor may throw an error. Here we are following the same logic described\r\n        // in result.catch() line above.\r\n        reject(e);\r\n      }\r\n    });\r\n\r\n    this.abort = abort;\r\n    this.reject = reject;\r\n  }\r\n\r\n  /**\r\n   * Aborts the promise execution using the specified reason.\r\n   *\r\n   * Not that this method doesn't reject the promise but notifies the executor using its context.\r\n   * To perform the same operation but also reject the promise, use the `reject()` method.\r\n   * @param reason - abort reason.\r\n   * @see reject\r\n   */\r\n  abort: (reason?: unknown) => void;\r\n\r\n  /**\r\n   * Aborts the promise with the cancel error.\r\n   */\r\n  cancel(): void {\r\n    this.abort(new CancelledError())\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\r\n  ): AbortablePromise<Result | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): AbortablePromise<Result> {\r\n    // Here we follow the same logic described in the \"then\" method.\r\n    return reassignProps(super.finally(onFinally) as AbortablePromise<Result>, this);\r\n  }\r\n\r\n  /**\r\n   * Rejects the initially created promise.\r\n   *\r\n   * This method not only aborts the signal passed to the executor, but also rejects the\r\n   * promise itself calling all chained listeners.\r\n   *\r\n   * The reason passed to the method is being passed as-is to the executor's context.\r\n   */\r\n  reject: PromiseRejectFn;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = Result, B = never>(\r\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<Result, A>>,\r\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\r\n  ): AbortablePromise<A | B> {\r\n    // Use the original promise \"then\" method because in fact, it creates an AbortablePromise\r\n    // instance.\r\n    // Then, reassign the promise \"reject\" method, because not doing it and rejecting the promise\r\n    // it will lead to an unhandled promise rejection.\r\n    //\r\n    // Here is an example:\r\n    // const myPromise = new AbortablePromise(...)\r\n    //   .catch(() => console.log('Catched'));\r\n    //\r\n    // If we don't reassign myPromise's \"reject\" method here, it will reject the promise, returned\r\n    // from the \"catch\" method, which is unexpected. So, even using several catches in a row,\r\n    // a developer will not be able to catch the error, thrown using the \"reject\" method.\r\n    //\r\n    // The expected behavior here is the \"reject\" method rejecting the initially created promise.\r\n    // Then, this error will be handled via the \"catch\" method.\r\n    return reassignProps(super.then(onFulfilled, onRejected) as AbortablePromise<A | B>, this);\r\n  }\r\n}\r\n","import { AbortablePromise } from './AbortablePromise.js';\r\nimport type {\r\n  PromiseExecutorFn,\r\n  PromiseOnRejectedFn,\r\n  PromiseOnFulfilledFn,\r\n  PromiseResolveFn,\r\n  PromiseOptions,\r\n  Maybe,\r\n  WithFnFunction,\r\n} from './types.js';\r\n\r\nfunction assignResolve<P extends ManualPromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: ManualPromise<any>,\r\n): P {\r\n  childPromise.resolve = parentPromise.resolve;\r\n  return childPromise;\r\n}\r\n\r\nexport class ManualPromise<T> extends AbortablePromise<T> {\r\n  /**\r\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\r\n   * was returned.\r\n   * @param fn - function returning promise result.\r\n   * @param options - additional options.\r\n   */\r\n  static fn<T>(fn: WithFnFunction<T>, options?: PromiseOptions): ManualPromise<T> {\r\n    return new ManualPromise((res, rej, signal) => {\r\n      try {\r\n        Promise.resolve(fn(signal)).then(res, rej);\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): ManualPromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): ManualPromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): ManualPromise<Awaited<T>> {\r\n    return this.fn(() => value) as ManualPromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject<T = never>(reason?: any,): ManualPromise<T> {\r\n    return new ManualPromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new ManualPromise instance using only options.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(options?: PromiseOptions);\r\n  /**\r\n   * Creates a new ManualPromise instance using specified executor and additional options.\r\n   * @param executor - promise executor.\r\n   * @param options - additional options.\r\n   */\r\n  constructor(executor?: PromiseExecutorFn<T>, options?: PromiseOptions);\r\n  constructor(\r\n    executorOrOptions?: PromiseExecutorFn<T> | PromiseOptions,\r\n    maybeOptions?: PromiseOptions,\r\n  ) {\r\n    let executor: PromiseExecutorFn<T> | undefined;\r\n    let options: PromiseOptions | undefined;\r\n\r\n    if (typeof executorOrOptions === 'function') {\r\n      executor = executorOrOptions;\r\n      options = maybeOptions;\r\n    } else {\r\n      options = executorOrOptions;\r\n    }\r\n\r\n    let resolve!: PromiseResolveFn<T>;\r\n    super((res, rej, context) => {\r\n      resolve = res;\r\n      executor && executor(res, rej, context);\r\n    }, options);\r\n    this.resolve = resolve;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<PromiseOnRejectedFn<CatchResult>>,\r\n  ): ManualPromise<T | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): ManualPromise<T> {\r\n    // Here, we are completely following the logic, described in the AbortablePromise.finally.\r\n    return assignResolve(super.finally(onFinally) as ManualPromise<T>, this);\r\n  }\r\n\r\n  /**\r\n   * Resolves the promise.\r\n   */\r\n  resolve: PromiseResolveFn<T>;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = T, B = never>(\r\n    onFulfilled?: Maybe<PromiseOnFulfilledFn<T, A>>,\r\n    onRejected?: Maybe<PromiseOnRejectedFn<B>>,\r\n  ): ManualPromise<A | B> {\r\n    // Here, we are completely following the logic, described in the AbortablePromise.then.\r\n    return assignResolve(super.then(onFulfilled, onRejected) as ManualPromise<A | B>, this);\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}