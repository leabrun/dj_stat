{"ast":null,"code":"let r;\nfunction y(e, c) {\n  r && r.set(e, c) || c();\n}\nfunction m(e) {\n  if (r) return e();\n  r = /* @__PURE__ */new Map();\n  try {\n    e();\n  } finally {\n    r.forEach(c => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [],\n    s = e;\n  const i = t => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(([f, d]) => {\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? {\n      once: t\n    } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n      const f = a(l),\n        d = u.findIndex(([h, p]) => h === t && p.once === f.once && p.signal === f.signal);\n      d >= 0 && u.splice(d, 1);\n    },\n    o = Object.assign(function () {\n      return j(o), s;\n    }, {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter(t => t[1].signal);\n      }\n    });\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */new Set(),\n    u;\n  function s() {\n    return u || (u = /* @__PURE__ */S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach(t => {\n      t.unsub(i, {\n        signal: !0\n      });\n    });\n    const n = /* @__PURE__ */new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach(t => {\n      t.sub(i, {\n        signal: !0\n      });\n    }), g = n, o;\n  }\n  return Object.assign(function () {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...n) {\n      return s().sub(...n);\n    },\n    unsub(...n) {\n      s().unsub(...n);\n    },\n    unsubAll(...n) {\n      s().unsubAll(...n);\n    }\n  });\n}\nexport { m as batch, x as computed, S as signal };","map":{"version":3,"names":["r","y","e","c","set","m","Map","forEach","S","g","equals","Object","is","u","s","i","t","l","o","f","d","n","a","once","signal","unsub","findIndex","h","p","splice","assign","j","destroy","reset","sub","push","unsubAll","filter","b","length","add","x","Set","pop"],"sources":["/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/signals/src/batch.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/signals/src/signal.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/signals/src/computed.ts"],"sourcesContent":["import { Signal } from './signal.js';\n\nlet callbacks: Map<Signal<any>, () => void> | undefined;\n\nexport function runInBatchMode(signal: Signal<any>, fn: () => void): void {\n  callbacks && callbacks.set(signal, fn) || fn();\n}\n\n/**\n * Runs the specified function in the batch mode.\n *\n * It makes all signals' subscribers to be called only after signals changes inside the specified\n * function were applied.\n * @param fn - function to run in the batch mode.\n * @example\n * const a = signal(1);\n * const b = signal(1);\n * const c = computed(() => a() + b());\n *\n * function subscriber(value) {\n *   console.log(value);\n * }\n *\n * c.sub(subscriber);\n *\n * batch(() => {\n *   a.set(2);\n *   a.set(3);\n *   b.set(2);\n *   b.set(3);\n * });\n *\n * // Despite the fact that we called signals setters four times, the `subscriber` function will\n * // be called only once. Removing the `batch` function usage will lead to calling the `subscriber`\n * // function four times.\n */\nexport function batch(fn: () => void): void {\n  // There could be a case when a batch is called inside other batches.\n  // In this case, we should just ignore the current call.\n  if (callbacks) {\n    return fn();\n  }\n  callbacks = new Map();\n\n  try {\n    fn();\n  } finally {\n    callbacks.forEach(cb => cb());\n    callbacks = undefined;\n    // TODO: What if something went wrong in fn or its callbacks?\n  }\n}\n","import { collectSignal } from './computed.js';\nimport { runInBatchMode } from './batch.js';\n\nexport type SubscribeListenerFn<T> = (current: T, previous: T) => void;\nexport type RemoveListenerFn = () => void;\n\nexport interface SignalOptions<T> {\n  /**\n   * Previous and next values comparator.\n   *\n   * This function is used during the actual and incoming values comparison in the `set` method.\n   * If values are considered the same, no subscribers will be called.\n   *\n   * @default Object.is\n   * @param current - the actual value.\n   * @param next - an incoming value.\n   * @returns True if values are considered the same.\n   */\n  equals?: (current: T, next: T) => boolean;\n}\n\nexport interface SubOptions {\n  /**\n   * Should the listener be called only once.\n   */\n  once?: boolean;\n  /**\n   * Was this listener added by other signal.\n   */\n  signal?: boolean;\n}\n\nexport interface Signal<T> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n  /**\n   * Destroys the signal removing all bound listeners.\n   *\n   * We usually use this method when the signal is not needed anymore.\n   *\n   * Take note that as long as call of this method removes all bound listeners, computed signals\n   * based on the current one will stop listening to its changes, possibly making it work\n   * improperly.\n   */\n  destroy: () => void;\n  /**\n   * Resets the signal to its initial value.\n   */\n  reset: () => void;\n  /**\n   * Updates the signal notifying all subscribers about changes.\n   * @param value - value to set.\n   */\n  set: (value: T) => void;\n  /**\n   * Adds a new listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options.\n   * @returns A function to remove the bound listener.\n   */\n  sub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => RemoveListenerFn;\n  /**\n   * Removes a listener, tracking the signal changes.\n   * @param fn - event listener.\n   * @param onceOrOptions - was this listener added for a single call, or additional\n   * options. Default: false\n   */\n  unsub: (fn: SubscribeListenerFn<T>, onceOrOptions?: boolean | SubOptions) => void;\n  /**\n   * Remove all non-signal listeners.\n   */\n  unsubAll: () => void;\n}\n\n/**\n * Creates a new signal with initial value.\n * @param initialValue - initial value.\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without initial value.\n * @param initialValue\n * @param options - additional options.\n */\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function signal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  type CurrentSignal = Signal<T | undefined>;\n\n  options ||= {};\n  const equals = options.equals || Object.is;\n\n  let listeners: [\n    listener: SubscribeListenerFn<T | undefined>,\n    options: Required<SubOptions>\n  ][] = [];\n  let value: ReturnType<CurrentSignal> = initialValue;\n\n  const set: CurrentSignal['set'] = v => {\n    if (!equals(value, v)) {\n      const prev = value;\n      value = v;\n\n      // We are making a copy of listeners as long as they may mutate the listeners' array,\n      // leading to an unexpected behavior.\n      //\n      // We want the setter to make sure that all listeners will be called in predefined\n      // order within a single update frame.\n      runInBatchMode(s, () => {\n        [...listeners].forEach(([fn, once]) => {\n          fn(v, prev);\n\n          // Remove \"once\" listeners.\n          if (once) {\n            unsub(fn, true);\n          }\n        });\n      });\n    }\n  };\n\n  function formatSubOptions(onceOrOptions: boolean | SubOptions | undefined): Required<SubOptions> {\n    const options = typeof onceOrOptions !== 'object'\n      ? { once: onceOrOptions }\n      : onceOrOptions;\n    return {\n      once: options.once || false,\n      signal: options.signal || false,\n    };\n  }\n\n  const unsub: CurrentSignal['unsub'] = (fn, onceOrOptions) => {\n    const options = formatSubOptions(onceOrOptions);\n    const idx = listeners.findIndex(([listener, lOptions]) => {\n      return listener === fn\n        && lOptions.once === options.once\n        && lOptions.signal === options.signal;\n    });\n    if (idx >= 0) {\n      listeners.splice(idx, 1);\n    }\n  };\n\n  const s = Object.assign(\n    function get() {\n      collectSignal(s);\n      return value;\n    },\n    {\n      destroy() {\n        listeners = [];\n      },\n      set,\n      reset() {\n        set(initialValue);\n      },\n      sub(fn, onceOrOptions) {\n        listeners.push([fn, formatSubOptions(onceOrOptions)]);\n        return () => unsub(fn, onceOrOptions);\n      },\n      unsub,\n      unsubAll() {\n        listeners = listeners.filter(l => l[1].signal);\n      },\n    } satisfies Pick<CurrentSignal, 'destroy' | 'set' | 'reset' | 'sub' | 'unsub' | 'unsubAll'>,\n  );\n\n  return s;\n}\n","import { signal, type Signal, type SignalOptions } from './signal.js';\n\nexport interface Computed<T> extends Omit<Signal<T>, 'set' | 'reset'> {\n  /**\n   * @returns An underlying signal value.\n   */\n  (): T;\n}\n\nconst collectContexts: Set<Signal<unknown>>[] = [];\n\nexport function collectSignal(signal: Signal<any>): void {\n  collectContexts.length && collectContexts[collectContexts.length - 1].add(signal);\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function computed<T>(\n  fn: (prev?: T) => T,\n  options?: SignalOptions<T>,\n): Computed<T> {\n  let deps = new Set<Signal<unknown>>();\n\n  // An underlying signal.\n  let $signal: Signal<T> | undefined;\n\n  function s(): Signal<T> {\n    return $signal || ($signal = signal<T>(compute(), options));\n  }\n\n  function update() {\n    s().set(compute());\n  }\n\n  function compute(): T {\n    // As long as in this iteration, we may receive new signals as dependencies, we stop\n    // listening to the previous signals.\n    deps.forEach(s => {\n      s.unsub(update, { signal: true });\n    });\n\n    // Signals we collected during current computation.\n    const collectedSignals = new Set<Signal<unknown>>();\n    let result: T;\n\n    // Add this set to the global variable, so dependant signals will be catched.\n    collectContexts.push(collectedSignals);\n\n    try {\n      // Run the function and collect all called signals.\n      result = fn();\n    } finally {\n      // Remember to untrack the reactive context.\n      collectContexts.pop();\n    }\n\n    // Start tracking for all dependencies' changes and re-compute the computed value.\n    collectedSignals.forEach(s => {\n      s.sub(update, { signal: true });\n    });\n    deps = collectedSignals;\n\n    return result;\n  }\n\n  return Object.assign(function computed(): T {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...args) {\n      return s().sub(...args);\n    },\n    unsub(...args) {\n      s().unsub(...args);\n    },\n    unsubAll(...args) {\n      s().unsubAll(...args);\n    },\n  } satisfies Pick<Computed<T>, 'destroy' | 'sub' | 'unsub' | 'unsubAll'>);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}