{"ast":null,"code":"var _jsxFileName = \"/home/leabrun/python_/KWORK/dj/front/src/DJConsoleContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useRef } from 'react';\n\n// Create the context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DJConsoleContext = /*#__PURE__*/createContext();\n\n// Counter for reset events\nlet resetCounter = 0;\n\n// Provider component\nexport const DJConsoleProvider = ({\n  children\n}) => {\n  _s();\n  // State to trigger resets - incrementing this value triggers a reset\n  const [resetTrigger, setResetTrigger] = useState(0);\n  // Global volume state (0 to 1 for Audio API)\n  const [volume, setVolume] = useState(0.5);\n\n  // Recording states\n  const [isRecording, setIsRecording] = useState(false);\n  const [recordedAudio, setRecordedAudio] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n\n  // Refs for recording\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const recordingStreamRef = useRef(null);\n  const audioPlayerRef = useRef(null);\n\n  // Active sound tracks (for monitoring what's playing)\n  const [activeSounds, setActiveSounds] = useState(new Set());\n\n  // Function to register an active sound\n  const registerSound = soundId => {\n    setActiveSounds(prev => {\n      const newSet = new Set(prev);\n      newSet.add(soundId);\n      return newSet;\n    });\n  };\n\n  // Function to unregister an active sound\n  const unregisterSound = soundId => {\n    setActiveSounds(prev => {\n      const newSet = new Set(prev);\n      newSet.delete(soundId);\n      return newSet;\n    });\n  };\n\n  // Function to reset all buttons\n  const resetAllButtons = () => {\n    resetCounter++;\n    setResetTrigger(resetCounter);\n  };\n\n  // Function to update the volume\n  const updateVolume = newValue => {\n    setVolume(newValue / 100);\n  };\n\n  // Function to start recording\n  const startRecording = async () => {\n    if (isRecording) return;\n    try {\n      // Check if there are active sounds\n      if (activeSounds.size === 0) {\n        alert(\"Warning: No active sounds. Recording will be silent.\");\n      }\n\n      // Set up audio context and destination\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const destination = audioContext.createMediaStreamDestination();\n\n      // Create audio stream from the current audio output\n      const audioStream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      recordingStreamRef.current = audioStream;\n\n      // Create media recorder\n      const mediaRecorder = new MediaRecorder(audioStream);\n      mediaRecorderRef.current = mediaRecorder;\n\n      // Clear previous chunks\n      audioChunksRef.current = [];\n\n      // Set up event handlers\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n      mediaRecorder.onstop = () => {\n        // Create a blob from the recorded chunks\n        const audioBlob = new Blob(audioChunksRef.current, {\n          type: 'audio/wav'\n        });\n        const audioUrl = URL.createObjectURL(audioBlob);\n\n        // Save the recording\n        setRecordedAudio(audioUrl);\n\n        // Clean up\n        if (recordingStreamRef.current) {\n          recordingStreamRef.current.getTracks().forEach(track => track.stop());\n        }\n      };\n\n      // Start recording\n      mediaRecorder.start();\n      setIsRecording(true);\n    } catch (error) {\n      console.error(\"Error starting recording:\", error);\n      alert(\"Could not start recording. Please ensure microphone access is allowed.\");\n    }\n  };\n\n  // Function to stop recording\n  const stopRecording = () => {\n    if (!isRecording || !mediaRecorderRef.current) return;\n    mediaRecorderRef.current.stop();\n    setIsRecording(false);\n  };\n\n  // Function to play recorded audio\n  const playRecording = () => {\n    if (!recordedAudio || isPlaying) return;\n    if (!audioPlayerRef.current) {\n      audioPlayerRef.current = new Audio(recordedAudio);\n      audioPlayerRef.current.onended = () => {\n        setIsPlaying(false);\n      };\n    } else {\n      audioPlayerRef.current.src = recordedAudio;\n    }\n    audioPlayerRef.current.volume = volume;\n    audioPlayerRef.current.play().catch(err => console.error(\"Playback error:\", err));\n    setIsPlaying(true);\n  };\n\n  // Function to pause playback\n  const pauseRecording = () => {\n    if (!isPlaying || !audioPlayerRef.current) return;\n    audioPlayerRef.current.pause();\n    setIsPlaying(false);\n  };\n\n  // The context value\n  const contextValue = {\n    resetTrigger,\n    resetAllButtons,\n    volume,\n    updateVolume,\n    isRecording,\n    startRecording,\n    stopRecording,\n    recordedAudio,\n    isPlaying,\n    playRecording,\n    pauseRecording,\n    registerSound,\n    unregisterSound,\n    hasActiveSounds: activeSounds.size > 0\n  };\n  return /*#__PURE__*/_jsxDEV(DJConsoleContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 168,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the DJ console context\n_s(DJConsoleProvider, \"fv93PWRVxbHTEEYlcPIQlzdtmmA=\");\n_c = DJConsoleProvider;\nexport const useDJConsole = () => {\n  _s2();\n  const context = useContext(DJConsoleContext);\n  if (context === undefined) {\n    throw new Error('useDJConsole must be used within a DJConsoleProvider');\n  }\n  return context;\n};\n_s2(useDJConsole, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"DJConsoleProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useRef","jsxDEV","_jsxDEV","DJConsoleContext","resetCounter","DJConsoleProvider","children","_s","resetTrigger","setResetTrigger","volume","setVolume","isRecording","setIsRecording","recordedAudio","setRecordedAudio","isPlaying","setIsPlaying","mediaRecorderRef","audioChunksRef","recordingStreamRef","audioPlayerRef","activeSounds","setActiveSounds","Set","registerSound","soundId","prev","newSet","add","unregisterSound","delete","resetAllButtons","updateVolume","newValue","startRecording","size","alert","audioContext","window","AudioContext","webkitAudioContext","destination","createMediaStreamDestination","audioStream","navigator","mediaDevices","getUserMedia","audio","current","mediaRecorder","MediaRecorder","ondataavailable","event","data","push","onstop","audioBlob","Blob","type","audioUrl","URL","createObjectURL","getTracks","forEach","track","stop","start","error","console","stopRecording","playRecording","Audio","onended","src","play","catch","err","pauseRecording","pause","contextValue","hasActiveSounds","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useDJConsole","_s2","context","undefined","Error","$RefreshReg$"],"sources":["/home/leabrun/python_/KWORK/dj/front/src/DJConsoleContext.jsx"],"sourcesContent":["import React, { createContext, useState, useContext, useRef } from 'react';\n\n// Create the context\nconst DJConsoleContext = createContext();\n\n// Counter for reset events\nlet resetCounter = 0;\n\n// Provider component\nexport const DJConsoleProvider = ({ children }) => {\n  // State to trigger resets - incrementing this value triggers a reset\n  const [resetTrigger, setResetTrigger] = useState(0);\n  // Global volume state (0 to 1 for Audio API)\n  const [volume, setVolume] = useState(0.5);\n  \n  // Recording states\n  const [isRecording, setIsRecording] = useState(false);\n  const [recordedAudio, setRecordedAudio] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  \n  // Refs for recording\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const recordingStreamRef = useRef(null);\n  const audioPlayerRef = useRef(null);\n  \n  // Active sound tracks (for monitoring what's playing)\n  const [activeSounds, setActiveSounds] = useState(new Set());\n  \n  // Function to register an active sound\n  const registerSound = (soundId) => {\n    setActiveSounds(prev => {\n      const newSet = new Set(prev);\n      newSet.add(soundId);\n      return newSet;\n    });\n  };\n  \n  // Function to unregister an active sound\n  const unregisterSound = (soundId) => {\n    setActiveSounds(prev => {\n      const newSet = new Set(prev);\n      newSet.delete(soundId);\n      return newSet;\n    });\n  };\n\n  // Function to reset all buttons\n  const resetAllButtons = () => {\n    resetCounter++;\n    setResetTrigger(resetCounter);\n  };\n\n  // Function to update the volume\n  const updateVolume = (newValue) => {\n    setVolume(newValue / 100);\n  };\n  \n  // Function to start recording\n  const startRecording = async () => {\n    if (isRecording) return;\n    \n    try {\n      // Check if there are active sounds\n      if (activeSounds.size === 0) {\n        alert(\"Warning: No active sounds. Recording will be silent.\");\n      }\n      \n      // Set up audio context and destination\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const destination = audioContext.createMediaStreamDestination();\n      \n      // Create audio stream from the current audio output\n      const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      recordingStreamRef.current = audioStream;\n      \n      // Create media recorder\n      const mediaRecorder = new MediaRecorder(audioStream);\n      mediaRecorderRef.current = mediaRecorder;\n      \n      // Clear previous chunks\n      audioChunksRef.current = [];\n      \n      // Set up event handlers\n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n      \n      mediaRecorder.onstop = () => {\n        // Create a blob from the recorded chunks\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });\n        const audioUrl = URL.createObjectURL(audioBlob);\n        \n        // Save the recording\n        setRecordedAudio(audioUrl);\n        \n        // Clean up\n        if (recordingStreamRef.current) {\n          recordingStreamRef.current.getTracks().forEach(track => track.stop());\n        }\n      };\n      \n      // Start recording\n      mediaRecorder.start();\n      setIsRecording(true);\n    } catch (error) {\n      console.error(\"Error starting recording:\", error);\n      alert(\"Could not start recording. Please ensure microphone access is allowed.\");\n    }\n  };\n  \n  // Function to stop recording\n  const stopRecording = () => {\n    if (!isRecording || !mediaRecorderRef.current) return;\n    \n    mediaRecorderRef.current.stop();\n    setIsRecording(false);\n  };\n  \n  // Function to play recorded audio\n  const playRecording = () => {\n    if (!recordedAudio || isPlaying) return;\n    \n    if (!audioPlayerRef.current) {\n      audioPlayerRef.current = new Audio(recordedAudio);\n      \n      audioPlayerRef.current.onended = () => {\n        setIsPlaying(false);\n      };\n    } else {\n      audioPlayerRef.current.src = recordedAudio;\n    }\n    \n    audioPlayerRef.current.volume = volume;\n    audioPlayerRef.current.play().catch(err => console.error(\"Playback error:\", err));\n    setIsPlaying(true);\n  };\n  \n  // Function to pause playback\n  const pauseRecording = () => {\n    if (!isPlaying || !audioPlayerRef.current) return;\n    \n    audioPlayerRef.current.pause();\n    setIsPlaying(false);\n  };\n\n  // The context value\n  const contextValue = {\n    resetTrigger,\n    resetAllButtons,\n    volume,\n    updateVolume,\n    isRecording,\n    startRecording,\n    stopRecording,\n    recordedAudio,\n    isPlaying,\n    playRecording,\n    pauseRecording,\n    registerSound,\n    unregisterSound,\n    hasActiveSounds: activeSounds.size > 0\n  };\n\n  return (\n    <DJConsoleContext.Provider value={contextValue}>\n      {children}\n    </DJConsoleContext.Provider>\n  );\n};\n\n// Custom hook to use the DJ console context\nexport const useDJConsole = () => {\n  const context = useContext(DJConsoleContext);\n  if (context === undefined) {\n    throw new Error('useDJConsole must be used within a DJConsoleProvider');\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}