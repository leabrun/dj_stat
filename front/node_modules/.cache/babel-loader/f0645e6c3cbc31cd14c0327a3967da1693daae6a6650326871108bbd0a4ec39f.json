{"ast":null,"code":"var b;\n// @__NO_SIDE_EFFECTS__\nfunction N(e) {\n  return {\n    lang: (e == null ? void 0 : e.lang) ?? (b == null ? void 0 : b.lang),\n    message: e == null ? void 0 : e.message,\n    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (b == null ? void 0 : b.abortEarly),\n    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (b == null ? void 0 : b.abortPipeEarly)\n  };\n}\nvar D;\n// @__NO_SIDE_EFFECTS__\nfunction Z(e) {\n  return D == null ? void 0 : D.get(e);\n}\nvar P;\n// @__NO_SIDE_EFFECTS__\nfunction ee(e) {\n  return P == null ? void 0 : P.get(e);\n}\nvar j;\n// @__NO_SIDE_EFFECTS__\nfunction ne(e, n) {\n  var r;\n  return (r = j == null ? void 0 : j.get(e)) == null ? void 0 : r.get(n);\n}\n// @__NO_SIDE_EFFECTS__\nfunction re(e) {\n  var r, t;\n  const n = typeof e;\n  return n === \"string\" ? `\"${e}\"` : n === \"number\" || n === \"bigint\" || n === \"boolean\" ? `${e}` : n === \"object\" || n === \"function\" ? (e && ((t = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : t.name)) ?? \"null\" : n;\n}\nfunction f(e, n, r, t, s) {\n  const u = s && \"input\" in s ? s.input : r.value,\n    i = (s == null ? void 0 : s.expected) ?? e.expects ?? null,\n    l = (s == null ? void 0 : s.received) ?? /* @__PURE__ */re(u),\n    o = {\n      kind: e.kind,\n      type: e.type,\n      input: u,\n      expected: i,\n      received: l,\n      message: `Invalid ${n}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${l}`,\n      requirement: e.requirement,\n      path: s == null ? void 0 : s.path,\n      issues: s == null ? void 0 : s.issues,\n      lang: t.lang,\n      abortEarly: t.abortEarly,\n      abortPipeEarly: t.abortPipeEarly\n    },\n    y = e.kind === \"schema\",\n    p = (s == null ? void 0 : s.message) ?? e.message ?? /* @__PURE__ */ne(e.reference, o.lang) ?? (y ? /* @__PURE__ */ee(o.lang) : null) ?? t.message ?? /* @__PURE__ */Z(o.lang);\n  p && (o.message = typeof p == \"function\" ?\n  // @ts-expect-error\n  p(o) : p), y && (r.typed = !1), r.issues ? r.issues.push(o) : r.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction h(e) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(n) {\n      return e[\"~run\"]({\n        value: n\n      }, /* @__PURE__ */N());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction W(e, n) {\n  return Object.hasOwn(e, n) && n !== \"__proto__\" && n !== \"prototype\" && n !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(e, n) {\n  const r = [...new Set(e)];\n  return r.length > 1 ? `(${r.join(` ${n} `)})` : r[0] ?? \"never\";\n}\nvar se = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(e) {\n    super(e[0].message), this.name = \"ValiError\", this.issues = e;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction L(e, n) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: L,\n    async: !1,\n    expects: null,\n    requirement: e,\n    message: n,\n    \"~run\"(r, t) {\n      return r.typed && !this.requirement(r.value) && f(this, \"input\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(e) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: R,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && f(this, \"integer\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(e) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: d,\n    async: !1,\n    operation: e,\n    \"~run\"(n) {\n      return n.value = this.operation(n.value), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(e, n, r) {\n  return typeof e.default == \"function\" ?\n  // @ts-expect-error\n  e.default(n, r) :\n  // @ts-expect-error\n  e.default;\n}\n// @__NO_SIDE_EFFECTS__\nfunction ie(e, n) {\n  return !e[\"~run\"]({\n    value: n\n  }, {\n    abortEarly: !0\n  }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(e) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: _,\n    expects: \"boolean\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"boolean\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction z(e) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: z,\n    expects: \"Date\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof Date ? isNaN(n.value) ? f(this, \"type\", n, r, {\n        received: '\"Invalid Date\"'\n      }) : n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction J(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: J,\n    expects: e.name,\n    async: !1,\n    class: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value instanceof this.class ? r.typed = !0 : f(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction A(e) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: A,\n    expects: \"unknown\",\n    async: !1,\n    getter: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(n, r) {\n      return this.getter(n.value)[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: k,\n    expects: \"Object\",\n    async: !1,\n    entries: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(r, t) {\n      var u;\n      const s = r.value;\n      if (s && typeof s == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const i in this.entries) {\n          const l = this.entries[i];\n          if (i in s || (l.type === \"exact_optional\" || l.type === \"optional\" || l.type === \"nullish\") &&\n          // @ts-expect-error\n          l.default !== void 0) {\n            const o = i in s ?\n              // @ts-expect-error\n              s[i] : /* @__PURE__ */U(l),\n              y = l[\"~run\"]({\n                value: o\n              }, t);\n            if (y.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const m of y.issues) m.path ? m.path.unshift(p) : m.path = [p], (u = r.issues) == null || u.push(m);\n              if (r.issues || (r.issues = y.issues), t.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            y.typed || (r.typed = !1), r.value[i] = y.value;\n          } else if (l.type !== \"exact_optional\" && l.type !== \"optional\" && l.type !== \"nullish\" && (f(this, \"key\", r, t, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [{\n              type: \"object\",\n              origin: \"key\",\n              input: s,\n              key: i,\n              // @ts-expect-error\n              value: s[i]\n            }]\n          }), t.abortEarly)) break;\n        }\n        if (!r.issues || !t.abortEarly) for (const i in s) /* @__PURE__ */W(s, i) && !(i in this.entries) && (r.value[i] = s[i]);\n      } else f(this, \"type\", r, t);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction E(e) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: E,\n    expects: \"number\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"number\" && !isNaN(n.value) ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction c(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: c,\n    expects: `(${e.expects} | undefined)`,\n    async: !1,\n    wrapped: e,\n    default: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value === void 0 && (this.default !== void 0 && (r.value = /* @__PURE__ */U(this, r, t)), r.value === void 0) ? (r.typed = !0, r) : this.wrapped[\"~run\"](r, t);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(e, n, r) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: V,\n    expects: \"Object\",\n    async: !1,\n    key: e,\n    value: n,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(t, s) {\n      var i, l;\n      const u = t.value;\n      if (u && typeof u == \"object\") {\n        t.typed = !0, t.value = {};\n        for (const o in u) if (/* @__PURE__ */W(u, o)) {\n          const y = u[o],\n            p = this.key[\"~run\"]({\n              value: o\n            }, s);\n          if (p.issues) {\n            const S = {\n              type: \"object\",\n              origin: \"key\",\n              input: u,\n              key: o,\n              value: y\n            };\n            for (const g of p.issues) g.path = [S], (i = t.issues) == null || i.push(g);\n            if (t.issues || (t.issues = p.issues), s.abortEarly) {\n              t.typed = !1;\n              break;\n            }\n          }\n          const m = this.value[\"~run\"]({\n            value: y\n          }, s);\n          if (m.issues) {\n            const S = {\n              type: \"object\",\n              origin: \"value\",\n              input: u,\n              key: o,\n              value: y\n            };\n            for (const g of m.issues) g.path ? g.path.unshift(S) : g.path = [S], (l = t.issues) == null || l.push(g);\n            if (t.issues || (t.issues = m.issues), s.abortEarly) {\n              t.typed = !1;\n              break;\n            }\n          }\n          (!p.typed || !m.typed) && (t.typed = !1), p.typed && (t.value[p.value] = m.value);\n        }\n      } else f(this, \"type\", t, s);\n      return t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction a(e) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: a,\n    expects: \"string\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"string\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction O(e) {\n  let n;\n  if (e) for (const r of e) n ? n.push(...r.issues) : n = r.issues;\n  return n;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: $,\n    expects: /* @__PURE__ */te(e.map(r => r.expects), \"|\"),\n    async: !1,\n    options: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(r, t) {\n      let s, u, i;\n      for (const l of this.options) {\n        const o = l[\"~run\"]({\n          value: r.value\n        }, t);\n        if (o.typed) {\n          if (o.issues) u ? u.push(o) : u = [o];else {\n            s = o;\n            break;\n          }\n        } else i ? i.push(o) : i = [o];\n      }\n      if (s) return s;\n      if (u) {\n        if (u.length === 1) return u[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */O(u)\n        }), r.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1) return i[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */O(i)\n        });\n      }\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: q,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(e) {\n      return e.typed = !0, e;\n    }\n  };\n}\nfunction B(e, n, r) {\n  const t = e[\"~run\"]({\n    value: n\n  }, /* @__PURE__ */N(r));\n  if (t.issues) throw new se(t.issues);\n  return t.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(...e) {\n  return {\n    ...e[0],\n    pipe: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */h(this);\n    },\n    \"~run\"(n, r) {\n      for (const t of e) if (t.kind !== \"metadata\") {\n        if (n.issues && (t.kind === \"schema\" || t.kind === \"transformation\")) {\n          n.typed = !1;\n          break;\n        }\n        (!n.issues || !r.abortEarly && !r.abortPipeEarly) && (n = t[\"~run\"](n, r));\n      }\n      return n;\n    }\n  };\n}\nfunction ue(e) {\n  return e.replace(/_[a-z]/g, n => n[1].toUpperCase());\n}\nfunction ae(e) {\n  return Object.entries(e).reduce((n, [r, t]) => (n[ue(r)] = t, n), {});\n}\nfunction w(e) {\n  const n = ae(e);\n  for (const r in n) {\n    const t = n[r];\n    t && typeof t == \"object\" && !(t instanceof Date) && (n[r] = Array.isArray(t) ? t.map(w) : w(t));\n  }\n  return n;\n}\nfunction I(e) {\n  return /* @__PURE__ */d(n => e ? w(n) : n);\n}\nfunction M(e) {\n  return n => /* @__PURE__ */v(e, I(n));\n}\nfunction T(e) {\n  return (n, r) => B(/* @__PURE__ */v(e, I(r)), n);\n}\nfunction oe() {\n  return /* @__PURE__ */d(JSON.parse);\n}\nfunction C(e) {\n  const n = M(e);\n  return r => /* @__PURE__ */v(/* @__PURE__ */a(), oe(), n(r));\n}\nfunction ce(e) {\n  return /* @__PURE__ */d(n => {\n    const r = {};\n    return new URLSearchParams(n).forEach((t, s) => {\n      const u = r[s];\n      Array.isArray(u) ? u.push(t) : u === void 0 ? r[s] = t : r[s] = [u, t];\n    }), B(e, r);\n  });\n}\nfunction K(e) {\n  return n => /* @__PURE__ */v(/* @__PURE__ */$([/* @__PURE__ */a(), /* @__PURE__ */J(URLSearchParams)]), ce(e), I(n));\n}\nconst Q = /* @__PURE__ */c(/* @__PURE__ */A(() => he())),\n  le = /* @__PURE__ */k({\n    id: /* @__PURE__ */E(),\n    photo_url: /* @__PURE__ */c(/* @__PURE__ */a()),\n    type: /* @__PURE__ */a(),\n    title: /* @__PURE__ */a(),\n    username: /* @__PURE__ */c(/* @__PURE__ */a())\n  }),\n  pe = /* @__PURE__ */k({\n    added_to_attachment_menu: /* @__PURE__ */c(/* @__PURE__ */_()),\n    allows_write_to_pm: /* @__PURE__ */c(/* @__PURE__ */_()),\n    first_name: /* @__PURE__ */a(),\n    id: /* @__PURE__ */E(),\n    is_bot: /* @__PURE__ */c(/* @__PURE__ */_()),\n    is_premium: /* @__PURE__ */c(/* @__PURE__ */_()),\n    last_name: /* @__PURE__ */c(/* @__PURE__ */a()),\n    language_code: /* @__PURE__ */c(/* @__PURE__ */a()),\n    photo_url: /* @__PURE__ */c(/* @__PURE__ */a()),\n    username: /* @__PURE__ */c(/* @__PURE__ */a())\n  }),\n  fe = /* @__PURE__ */k({\n    auth_date: /* @__PURE__ */v(/* @__PURE__ */a(), /* @__PURE__ */d(e => new Date(Number(e) * 1e3)), /* @__PURE__ */z()),\n    can_send_after: /* @__PURE__ */c(/* @__PURE__ */v(/* @__PURE__ */a(), /* @__PURE__ */d(Number), /* @__PURE__ */R())),\n    chat: /* @__PURE__ */c(/* @__PURE__ */A(() => ye())),\n    chat_type: /* @__PURE__ */c(/* @__PURE__ */a()),\n    chat_instance: /* @__PURE__ */c(/* @__PURE__ */a()),\n    hash: /* @__PURE__ */a(),\n    query_id: /* @__PURE__ */c(/* @__PURE__ */a()),\n    receiver: Q,\n    start_param: /* @__PURE__ */c(/* @__PURE__ */a()),\n    signature: /* @__PURE__ */a(),\n    user: Q\n  }),\n  ye = C(le),\n  he = C(pe),\n  F = K(fe);\nfunction H(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction me(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction ge(e) {\n  const n = e.replace(/\\s/g, \"\").toLowerCase();\n  if (H(n)) return n;\n  if (me(n)) {\n    let t = \"#\";\n    for (let s = 0; s < 3; s += 1) t += n[1 + s].repeat(2);\n    return t;\n  }\n  const r = n.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || n.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r) throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((t, s) => t + parseInt(s, 10).toString(16).padStart(2, \"0\"), \"#\");\n}\nconst be = M(/* @__PURE__ */V(/* @__PURE__ */a(), /* @__PURE__ */v(/* @__PURE__ */$([/* @__PURE__ */a(), /* @__PURE__ */E()]), /* @__PURE__ */d(e => typeof e == \"number\" ? `#${(e & 16777215).toString(16).padStart(6, \"0\")}` : e), /* @__PURE__ */L(H)))),\n  x = /* @__PURE__ */c(/* @__PURE__ */v(/* @__PURE__ */a(), /* @__PURE__ */d(e => e === \"1\"))),\n  G = C(be()),\n  de = /* @__PURE__ */k({\n    tgWebAppBotInline: x,\n    tgWebAppData: /* @__PURE__ */c(F()),\n    tgWebAppDefaultColors: /* @__PURE__ */c(G()),\n    tgWebAppFullscreen: x,\n    tgWebAppPlatform: /* @__PURE__ */a(),\n    tgWebAppShowSettings: x,\n    tgWebAppStartParam: /* @__PURE__ */c(/* @__PURE__ */a()),\n    tgWebAppThemeParams: G(),\n    tgWebAppVersion: /* @__PURE__ */a()\n  }),\n  X = K(de),\n  ke = T(F()),\n  _e = T(X()),\n  Se = /* @__PURE__ */k({\n    eventType: /* @__PURE__ */a(),\n    eventData: /* @__PURE__ */c(/* @__PURE__ */q())\n  });\nfunction Y(e, n) {\n  return n || (n = (r, t) => JSON.stringify(t)), new URLSearchParams(Object.entries(e).reduce((r, [t, s]) => (Array.isArray(s) ? r.push(...s.map(u => [t, String(u)])) : s != null && r.push([t, s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : n(t, s)]), r), [])).toString();\n}\nfunction ve(e) {\n  return Y(e);\n}\nfunction Ee(e) {\n  return Y(e, (n, r) => n === \"tgWebAppData\" ? ve(r) : JSON.stringify(r));\n}\nfunction De(e) {\n  try {\n    return /* @__PURE__ */ie(X(), e);\n  } catch {\n    return !1;\n  }\n}\nexport { le as InitDataChatSchema, fe as InitDataQuerySchema, pe as InitDataUserSchema, de as LaunchParamsSchema, Se as MiniAppsMessageSchema, I as conditionalSnakeKeys, M as createCamelCaseGen, T as createCamelCaseSchemaParserGen, C as createJsonCamelCaseGen, K as createQueryCamelCaseGen, ye as initDataChatJson, F as initDataQuery, he as initDataUserJson, De as isLaunchParamsQuery, H as isRGB, me as isRGBShort, oe as jsonParse, X as launchParamsQuery, ke as parseInitDataQuery, _e as parseLaunchParamsQuery, ve as serializeInitDataQuery, Ee as serializeLaunchParamsQuery, Y as serializeToQuery, be as themeParams, ge as toRGB, ce as transformQueryUsing };","map":{"version":3,"names":["b","N","e","lang","message","abortEarly","abortPipeEarly","D","Z","get","P","ee","j","ne","n","r","re","t","Object","getPrototypeOf","constructor","name","f","s","u","input","value","i","expected","expects","l","received","o","kind","type","requirement","path","issues","y","p","reference","typed","push","h","version","vendor","validate","W","hasOwn","te","Set","length","join","se","Error","L","async","~run","R","Number","isInteger","d","operation","U","default","ie","_","~standard","z","Date","isNaN","J","class","A","getter","k","entries","origin","key","m","unshift","E","c","wrapped","V","S","g","a","O","$","map","options","q","B","v","pipe","ue","replace","toUpperCase","ae","reduce","w","Array","isArray","I","M","T","oe","JSON","parse","C","ce","URLSearchParams","forEach","K","Q","he","le","id","photo_url","title","username","pe","added_to_attachment_menu","allows_write_to_pm","first_name","is_bot","is_premium","last_name","language_code","fe","auth_date","can_send_after","chat","ye","chat_type","chat_instance","hash","query_id","receiver","start_param","signature","user","F","H","test","me","ge","toLowerCase","repeat","match","slice","parseInt","toString","padStart","be","x","G","de","tgWebAppBotInline","tgWebAppData","tgWebAppDefaultColors","tgWebAppFullscreen","tgWebAppPlatform","tgWebAppShowSettings","tgWebAppStartParam","tgWebAppThemeParams","tgWebAppVersion","X","ke","_e","Se","eventType","eventData","Y","onObject","stringify","String","getTime","ve","Ee","De"],"sources":["/home/leabrun/python_/KWORK/dj/front/node_modules/node_modules/.pnpm/valibot@1.0.0-beta.14_typescript@5.6.3/node_modules/valibot/dist/index.js","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/toolkit/dist/index.js","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/camel-casing/conditionalSnakeKeys.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/camel-casing/createCamelCaseGen.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/camel-casing/createCamelCaseSchemaParserGen.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/transformers/jsonParse.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/camel-casing/createJsonCamelCaseGen.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/transformers/transformQueryUsing.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/camel-casing/createQueryCamelCaseGen.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/schemas/init-data.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/generators/init-data.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/validation/rgb.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/generators/themeParams.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/schemas/LaunchParamsSchema.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/generators/launchParamsQuery.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/parsers/parseInitDataQuery.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/parsers/parseLaunchParamsQuery.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/schemas/MiniAppsMessageSchema.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/serializers/serializeToQuery.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/serializers/serializeInitDataQuery.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/serializers/serializeLaunchParamsQuery.ts","/home/leabrun/python_/KWORK/dj/front/node_modules/@telegram-apps/transformers/src/validation/isLaunchParamsQuery.ts"],"sourcesContent":["// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values, separator) {\n  const list = [...new Set(values)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?\\d+(?:\\.\\d+)?$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = /^[\\w.!#$%&'*+/=?^`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    pathList,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if (schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if ((await schema.entries[currentKey][\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  graphemes,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  metadata,\n  mimeType,\n  minBytes,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n","function C(o) {\n  return o.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction b(o) {\n  return o.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction $(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[b(t)] = n, e), {});\n}\nfunction p(o) {\n  return o.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction m(o) {\n  return Object.entries(o).reduce((e, [t, n]) => (e[p(t)] = n, e), {});\n}\nfunction s(o) {\n  const e = m(o);\n  for (const t in e) {\n    const n = e[t];\n    n && typeof n == \"object\" && !(n instanceof Date) && (e[t] = Array.isArray(n) ? n.map(s) : s(n));\n  }\n  return e;\n}\nfunction k(o) {\n  return o.replace(/_([a-z])/g, (e, t) => `-${t.toLowerCase()}`);\n}\nfunction u(o) {\n  return `tapps/${o}`;\n}\nfunction y(o, e) {\n  sessionStorage.setItem(u(o), JSON.stringify(e));\n}\nfunction S(o) {\n  const e = sessionStorage.getItem(u(o));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction h(...o) {\n  const e = o.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((t) => {\n        t();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction T(o, e) {\n  e || (e = {});\n  const {\n    textColor: t,\n    bgColor: n,\n    shouldLog: a\n  } = e, r = a === void 0 ? !0 : a, l = typeof r == \"boolean\" ? () => r : r;\n  function c(g, d, ...f) {\n    if (d || l()) {\n      const i = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n      console[g](\n        `%c${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c / %c${o}`,\n        `${i};background-color: lightblue;color:black`,\n        \"\",\n        `${i};${t ? `color:${t};` : \"\"}${n ? `background-color:${n}` : \"\"}`,\n        ...f\n      );\n    }\n  }\n  return [c.bind(void 0, \"log\"), c.bind(void 0, \"error\")];\n}\nexport {\n  C as camelToKebab,\n  b as camelToSnake,\n  $ as camelToSnakeObjKeys,\n  h as createCbCollector,\n  T as createLogger,\n  s as deepSnakeToCamelObjKeys,\n  S as getStorageValue,\n  y as setStorageValue,\n  p as snakeToCamel,\n  m as snakeToCamelObjKeys,\n  k as snakeToKebab\n};\n//# sourceMappingURL=index.js.map\n","import { transform, type TransformAction } from 'valibot';\nimport {\n  type DeepConvertSnakeKeysToCamelCase,\n  deepSnakeToCamelObjKeys,\n  type If,\n} from '@telegram-apps/toolkit';\n\nexport type ConditionalSnakeKeysAction<Input extends object, CamelCase extends boolean> =\n  TransformAction<\n    Input,\n    If<CamelCase, DeepConvertSnakeKeysToCamelCase<Input>, Input>\n  >;\n\n/**\n * Conditionally applies `deepSnakeToCamelObjKeys` to the input.\n * @param camelCase - true if the camel-casing must be applied.\n */\nexport function conditionalSnakeKeys<Input extends object>(\n  camelCase?: boolean,\n): ConditionalSnakeKeysAction<Input, false>;\n\n/**\n * Conditionally applies `deepSnakeToCamelObjKeys` to the input.\n * @param camelCase - true if the camel-casing must be applied.\n */\nexport function conditionalSnakeKeys<Input extends object>(\n  camelCase: true,\n): ConditionalSnakeKeysAction<Input, true>;\n\n/**\n * Conditionally applies `deepSnakeToCamelObjKeys` to the input.\n * @param camelCase - true if the camel-casing must be applied.\n */\nexport function conditionalSnakeKeys(camelCase?: boolean): ConditionalSnakeKeysAction<object, boolean> {\n  return transform(input => {\n    return camelCase ? deepSnakeToCamelObjKeys(input) : input;\n  });\n}","import {\n  type BaseIssue,\n  type BaseSchema,\n  type InferOutput,\n  pipe,\n  type SchemaWithPipe,\n} from 'valibot';\n\nimport {\n  conditionalSnakeKeys,\n  type ConditionalSnakeKeysAction,\n} from '@/camel-casing/conditionalSnakeKeys.js';\nimport type { CamelCaseTransformerFn } from '@/camel-casing/types.js';\n\ntype RequiredSchema = BaseSchema<unknown, object, BaseIssue<unknown>>;\n\nexport type CamelCaseTransformerPipe<Schema extends RequiredSchema, CamelCase extends boolean> =\n  SchemaWithPipe<[\n    Schema,\n    ConditionalSnakeKeysAction<InferOutput<Schema>, CamelCase>\n  ]>;\n\nexport type CamelCaseTransformer<Schema extends RequiredSchema> = CamelCaseTransformerFn<\n  CamelCaseTransformerPipe<Schema, false>,\n  CamelCaseTransformerPipe<Schema, true>\n>;\n\n/**\n * Creates a function that generates schemas deeply camel-casing output keys if needed.\n * @param schema - base schema used to validate the input.\n */\nexport function createCamelCaseGen<Schema extends RequiredSchema>(\n  schema: Schema,\n): CamelCaseTransformer<Schema> {\n  return ((camelCase?) => pipe(\n    schema,\n    conditionalSnakeKeys(camelCase as any),\n  )) as CamelCaseTransformer<Schema>;\n}\n","import { type BaseIssue, type BaseSchema, InferOutput, parse, pipe } from 'valibot';\nimport type { DeepConvertSnakeKeysToCamelCase } from '@telegram-apps/toolkit';\nimport { conditionalSnakeKeys } from '@/camel-casing/conditionalSnakeKeys.js';\n\nexport interface CamelCaseSchemaParser<Input, Output extends object> {\n  (input: Input, camelCase?: false): Output;\n  (input: Input, camelCase: true): DeepConvertSnakeKeysToCamelCase<Output>;\n}\n\nexport function createCamelCaseSchemaParserGen<\n  Input,\n  Schema extends BaseSchema<Input, object, BaseIssue<unknown>>\n>(schema: Schema): CamelCaseSchemaParser<Input, InferOutput<Schema>> {\n  return ((input, camelCase?) => parse(\n    pipe(schema, conditionalSnakeKeys(camelCase)),\n    input\n  )) as CamelCaseSchemaParser<Input, InferOutput<Schema>>;\n}","import { transform, TransformAction } from 'valibot';\n\nexport type JsonParseAction = TransformAction<string, unknown>;\n\n/**\n * @returns A transformer applying `JSON.parse` to the input.\n */\nexport function jsonParse(): JsonParseAction {\n  return transform(JSON.parse);\n}\n","import {\n  type BaseIssue,\n  type BaseSchema,\n  pipe,\n  type SchemaWithPipe,\n  string,\n  type StringSchema,\n  type TransformAction,\n} from 'valibot';\n\nimport {\n  type CamelCaseTransformerPipe,\n  createCamelCaseGen,\n} from '@/camel-casing/createCamelCaseGen.js';\nimport type { CamelCaseTransformerFn } from '@/camel-casing/types.js';\nimport { jsonParse } from '@/transformers/jsonParse.js';\n\ntype RequiredSchema = BaseSchema<unknown, object, BaseIssue<unknown>>;\n\nexport type CamelCaseJsonTransformerPipe<\n  Schema extends RequiredSchema,\n  CamelCase extends boolean\n> = SchemaWithPipe<[\n  StringSchema<undefined>,\n  TransformAction<string, unknown>,\n  CamelCaseTransformerPipe<Schema, CamelCase>,\n]>;\n\nexport type CamelCaseJsonTransformer<Schema extends RequiredSchema> = CamelCaseTransformerFn<\n  CamelCaseJsonTransformerPipe<Schema, false>,\n  CamelCaseJsonTransformerPipe<Schema, true>\n>;\n\n/**\n * Creates a transformer accepting a JSON object presented as string and returning a value based\n * on the passed schema.\n * @param schema - schema to use to transform the output\n */\nexport function createJsonCamelCaseGen<Schema extends RequiredSchema>(\n  schema: Schema,\n): CamelCaseJsonTransformer<Schema> {\n  const cc = createCamelCaseGen(schema);\n\n  return ((camelCase?) => pipe(\n    string(),\n    jsonParse(),\n    cc(camelCase as any),\n  )) as CamelCaseJsonTransformer<Schema>;\n}","import {\n  type BaseIssue,\n  type BaseSchema,\n  type InferOutput,\n  parse,\n  transform,\n  type TransformAction,\n} from 'valibot';\n\nexport type TransformQueryUsingAction<Schema extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>\n  = TransformAction<string | URLSearchParams, InferOutput<Schema>>\n\nexport function transformQueryUsing<Schema extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(\n  schema: Schema,\n): TransformQueryUsingAction<Schema> {\n  return transform(input => {\n    const result: Record<string, string | string[]> = {};\n\n    new URLSearchParams(input).forEach((value, key) => {\n      const accValue = result[key];\n      if (Array.isArray(accValue)) {\n        accValue.push(value);\n      } else if (accValue === undefined) {\n        result[key] = value;\n      } else {\n        result[key] = [accValue, value];\n      }\n    });\n\n    return parse(schema, result);\n  });\n}","import {\n  type BaseIssue,\n  type BaseSchema,\n  type InferOutput,\n  instance,\n  type InstanceSchema,\n  pipe,\n  type SchemaWithPipe,\n  string,\n  type StringSchema,\n  union,\n  type UnionSchema,\n} from 'valibot';\n\nimport {\n  conditionalSnakeKeys,\n  type ConditionalSnakeKeysAction,\n} from '@/camel-casing/conditionalSnakeKeys.js';\nimport type { CamelCaseTransformerFn } from '@/camel-casing/types.js';\nimport {\n  transformQueryUsing,\n  type TransformQueryUsingAction,\n} from '@/transformers/transformQueryUsing.js';\n\ntype RequiredSchema = BaseSchema<object, object, BaseIssue<unknown>>;\n\nexport type CamelCaseQueryTransformerPipe<\n  Schema extends RequiredSchema,\n  CamelCase extends boolean\n> = SchemaWithPipe<[\n  UnionSchema<[\n    StringSchema<undefined>,\n    InstanceSchema<typeof URLSearchParams, undefined>\n  ], undefined>,\n  TransformQueryUsingAction<Schema>,\n  ConditionalSnakeKeysAction<InferOutput<Schema>, CamelCase>\n]>;\n\nexport type CamelCaseQueryTransformer<Schema extends RequiredSchema> = CamelCaseTransformerFn<\n  CamelCaseQueryTransformerPipe<Schema, false>,\n  CamelCaseQueryTransformerPipe<Schema, true>\n>;\n\n/**\n * Creates a transformer accepting query parameters as string and returning a value based\n * on the passed schema.\n * @param schema - schema to use to transform the output\n */\nexport function createQueryCamelCaseGen<Schema extends RequiredSchema>(\n  schema: Schema,\n): CamelCaseQueryTransformer<Schema> {\n  return ((camelCase?) => pipe(\n    union([string(), instance(URLSearchParams)]),\n    transformQueryUsing(schema),\n    conditionalSnakeKeys<any>(camelCase),\n  )) as CamelCaseQueryTransformer<Schema>;\n}","import {\n  type BaseSchema, boolean,\n  date, integer, lazy,\n  looseObject,\n  number,\n  optional,\n  pipe,\n  string,\n  transform,\n} from 'valibot';\nimport type { Chat, InitData, User } from '@telegram-apps/types';\n\nimport { initDataChatJson, initDataUserJson } from '@/generators/init-data.js';\n\nconst lazyUser = optional(lazy(() => initDataUserJson()));\n\nexport const InitDataChatSchema = looseObject({\n  id: number(),\n  photo_url: optional(string()),\n  type: string(),\n  title: string(),\n  username: optional(string()),\n} satisfies { [K in keyof Chat]-?: BaseSchema<unknown, Chat[K], any> });\n\nexport const InitDataUserSchema = looseObject({\n  added_to_attachment_menu: optional(boolean()),\n  allows_write_to_pm: optional(boolean()),\n  first_name: string(),\n  id: number(),\n  is_bot: optional(boolean()),\n  is_premium: optional(boolean()),\n  last_name: optional(string()),\n  language_code: optional(string()),\n  photo_url: optional(string()),\n  username: optional(string()),\n} satisfies { [K in keyof User]-?: BaseSchema<unknown, User[K], any> });\n\nexport const InitDataQuerySchema = looseObject({\n  auth_date: pipe(\n    string(),\n    transform(input => new Date(Number(input) * 1000)),\n    date(),\n  ),\n  can_send_after: optional(pipe(string(), transform(Number), integer())),\n  chat: optional(lazy(() => initDataChatJson())),\n  chat_type: optional(string()),\n  chat_instance: optional(string()),\n  hash: string(),\n  query_id: optional(string()),\n  receiver: lazyUser,\n  start_param: optional(string()),\n  signature: string(),\n  user: lazyUser,\n} satisfies { [K in keyof InitData]-?: unknown });","import { createJsonCamelCaseGen } from '@/camel-casing/createJsonCamelCaseGen.js';\nimport {\n  InitDataChatSchema,\n  InitDataQuerySchema,\n  InitDataUserSchema,\n} from '@/schemas/init-data.js';\nimport { createQueryCamelCaseGen } from '@/camel-casing/createQueryCamelCaseGen.js';\n\nexport const initDataChatJson = createJsonCamelCaseGen(InitDataChatSchema);\n\nexport const initDataUserJson = createJsonCamelCaseGen(InitDataUserSchema);\n\nexport const initDataQuery = createQueryCamelCaseGen(InitDataQuerySchema);","import type { RGB, RGBShort } from '@telegram-apps/types';\n\n/**\n * Returns true in case, passed value has #RRGGBB format.\n * @param value - value to check.\n */\nexport function isRGB(value: string): value is RGB {\n  return /^#[\\da-f]{6}$/i.test(value);\n}\n\n/**\n * Returns true in case, passed value has #RGB format.\n * @param value - value to check.\n */\nexport function isRGBShort(value: string): value is RGBShort {\n  return /^#[\\da-f]{3}$/i.test(value);\n}\n\n/**\n * Converts passed value to #RRGGBB format. Accepts following color formats:\n * - `#RGB`\n * - `#RRGGBB`\n * - `rgb(1,2,3)`\n * - `rgba(1,2,3,4)`\n * @param value - value to convert.\n * @throws {Error} Passed value does not satisfy any of known RGB formats.\n */\nexport function toRGB(value: string): RGB {\n  const clean = value.replace(/\\s/g, '').toLowerCase();\n  if (isRGB(clean)) {\n    return clean;\n  }\n\n  if (isRGBShort(clean)) {\n    let color: RGB = '#';\n    for (let i = 0; i < 3; i += 1) {\n      color += clean[1 + i].repeat(2);\n    }\n    return color;\n  }\n\n  // Example valid values: rgb(0,3,10) rgba(32,114,8,0)\n  const match = clean.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/)\n    || clean.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n\n  // If this didn't work as well, we can't extract RGB color from passed text.\n  if (!match) {\n    throw new Error(`Value \"${value}\" does not satisfy any of known RGB formats.`);\n  }\n\n  // Otherwise, take R, G and B components, convert to hex and create #RRGGBB string.\n  return match.slice(1).reduce((acc, component) => {\n    return acc + parseInt(component, 10).toString(16).padStart(2, '0');\n  }, '#') as RGB;\n}\n","import {\n  check,\n  type CheckAction,\n  number,\n  type NumberSchema,\n  pipe,\n  record,\n  type RecordSchema,\n  type SchemaWithPipe,\n  string,\n  type StringSchema,\n  transform,\n  type TransformAction,\n  union,\n  type UnionSchema,\n} from 'valibot';\nimport type { RGB, KnownThemeParamsKey } from '@telegram-apps/types';\n\nimport {\n  type CamelCaseTransformer,\n  createCamelCaseGen,\n} from '@/camel-casing/createCamelCaseGen.js';\nimport { isRGB } from '@/validation/rgb.js';\n\nexport const themeParams = createCamelCaseGen(\n  record(\n    string(),\n    pipe(\n      union([string(), number()]),\n      transform(value => {\n        return typeof value === 'number'\n          ? `#${(value & 0x00FFFFFF).toString(16).padStart(6, '0')}`\n          : value;\n      }),\n      check(isRGB),\n    ),\n  ),\n) as CamelCaseTransformer<\n  RecordSchema<\n    SchemaWithPipe<[\n      StringSchema<undefined>,\n      TransformAction<string, KnownThemeParamsKey>,\n    ]>,\n    SchemaWithPipe<[\n      UnionSchema<[StringSchema<undefined>, NumberSchema<undefined>], any>,\n      TransformAction<string | number, string>,\n      CheckAction<RGB, undefined>\n    ]>,\n    undefined\n  >\n>;","import { type BaseSchema, looseObject, optional, pipe, string, transform } from 'valibot';\nimport type { LaunchParams } from '@telegram-apps/types';\n\nimport { themeParams } from '@/generators/themeParams.js';\nimport { initDataQuery } from '@/generators/init-data.js';\nimport { createJsonCamelCaseGen } from '@/camel-casing/createJsonCamelCaseGen.js';\n\nconst OptionalBoolean = optional(\n  pipe(string(), transform(v => v === '1')),\n);\nconst themeParamsJson = createJsonCamelCaseGen(themeParams());\n\nexport const LaunchParamsSchema = looseObject({\n  tgWebAppBotInline: OptionalBoolean,\n  tgWebAppData: optional(initDataQuery()),\n  tgWebAppDefaultColors: optional(themeParamsJson()),\n  tgWebAppFullscreen: OptionalBoolean,\n  tgWebAppPlatform: string(),\n  tgWebAppShowSettings: OptionalBoolean,\n  tgWebAppStartParam: optional(string()),\n  tgWebAppThemeParams: themeParamsJson(),\n  tgWebAppVersion: string(),\n} satisfies { [K in keyof LaunchParams]-?: BaseSchema<unknown, LaunchParams[K], any> });","import { createQueryCamelCaseGen } from '@/camel-casing/createQueryCamelCaseGen.js';\nimport { LaunchParamsSchema } from '@/schemas/LaunchParamsSchema.js';\n\nexport const launchParamsQuery = createQueryCamelCaseGen(LaunchParamsSchema);\n","import { InitDataQuerySchema } from '@/schemas/init-data.js';\nimport type { CamelCaseQueryTransformerPipe } from '@/camel-casing/createQueryCamelCaseGen.js';\nimport { createCamelCaseSchemaParserGen } from '@/camel-casing/createCamelCaseSchemaParserGen.js';\nimport { initDataQuery } from '@/generators/init-data.js';\n\nexport const parseInitDataQuery = createCamelCaseSchemaParserGen<\n  string | URLSearchParams,\n  CamelCaseQueryTransformerPipe<typeof InitDataQuerySchema, false>\n>(initDataQuery());\n","import { createCamelCaseSchemaParserGen } from '@/camel-casing/createCamelCaseSchemaParserGen.js';\nimport type { CamelCaseQueryTransformerPipe } from '@/camel-casing/createQueryCamelCaseGen.js';\nimport { LaunchParamsSchema } from '@/schemas/LaunchParamsSchema.js';\nimport { launchParamsQuery } from '@/generators/launchParamsQuery.js';\n\nexport const parseLaunchParamsQuery = createCamelCaseSchemaParserGen<\n  string | URLSearchParams,\n  CamelCaseQueryTransformerPipe<typeof LaunchParamsSchema, false>\n>(launchParamsQuery());","import { string, looseObject, unknown, optional } from 'valibot';\n\nexport const MiniAppsMessageSchema = looseObject({\n  eventType: string(),\n  eventData: optional(unknown()),\n});\n","/**\n * Converts the passed object to query parameters.\n * @param value - value to serialize.\n * @param onObject - function returning serialized object value.\n */\nexport function serializeToQuery(\n  value: object,\n  onObject?: (key: string, value: object) => string,\n): string {\n  onObject ||= (_, value) => JSON.stringify(value);\n\n  return new URLSearchParams(\n    Object\n      .entries(value)\n      .reduce<[string, string][]>((acc, [key, value]) => {\n        if (Array.isArray(value)) {\n          acc.push(...value.map(v => [key, String(v)] as [string, string]));\n        } else {\n          if (value !== null && value !== undefined) {\n            acc.push([\n              key,\n              value instanceof Date\n                ? (value.getTime() / 1000 | 0).toString()\n                : typeof value === 'string' || typeof value === 'number'\n                  ? String(value)\n                  : typeof value === 'boolean'\n                    ? value ? '1' : '0'\n                    : onObject(key, value),\n            ]);\n          }\n        }\n        return acc;\n      }, []),\n  ).toString();\n}","import { InferOutput } from 'valibot';\nimport { InitData } from '@telegram-apps/types';\n\nimport type { InitDataQuerySchema } from '@/schemas/init-data.js';\nimport { serializeToQuery } from '@/serializers/serializeToQuery.js';\n\nexport type InitDataLike = InferOutput<typeof InitDataQuerySchema> | InitData;\n\n/**\n * Serializes the InitDataQuery shape.\n * @param value - value to serialize.\n */\nexport function serializeInitDataQuery(value: InitDataLike): string {\n  return serializeToQuery(value);\n}","import type { LaunchParams } from '@telegram-apps/types';\nimport type { InferOutput } from 'valibot';\n\nimport type { LaunchParamsSchema } from '@/schemas/LaunchParamsSchema.js';\nimport { serializeToQuery } from '@/serializers/serializeToQuery.js';\nimport { serializeInitDataQuery } from '@/serializers/serializeInitDataQuery.js';\n\nexport type LaunchParamsLike = InferOutput<typeof LaunchParamsSchema> | LaunchParams;\n\n/**\n * Serializes the LaunchParamsQuery shape.\n * @param value - value to serialize.\n */\nexport function serializeLaunchParamsQuery(value: LaunchParamsLike): string {\n  return serializeToQuery(value, (k, v) => {\n    return k === 'tgWebAppData' ? serializeInitDataQuery(v as any) : JSON.stringify(v);\n  });\n}","import { is } from 'valibot';\n\nimport { launchParamsQuery } from '@/generators/launchParamsQuery.js';\n\n/**\n * @returns True if the passed value contains valid launch parameters query.\n */\nexport function isLaunchParamsQuery(value: string | URLSearchParams): boolean {\n  try {\n    return is(launchParamsQuery(), value);\n  } catch {\n    return false;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}